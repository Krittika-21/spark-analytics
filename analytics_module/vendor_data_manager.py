"""
ABOUT: VendorDataManager for storing supplier data in Azure Cosmos DB
ABOUT: Extends CosmosDBBase with vendor-specific operations and data transformation
"""

import os
import logging
import hashlib
from typing import List, Dict, Optional
from datetime import datetime

from azure.cosmos.aio import CosmosClient as AsyncCosmosClient
from CosmosDBBase import CosmosDBBase

from dotenv import load_dotenv
load_dotenv()

class VendorDataManager(CosmosDBBase):
    """Manages vendor data storage in Azure Cosmos DB"""
    
    def __init__(self):
        # Azure Cosmos DB configuration from environment
        self.endpoint = os.getenv("AZURE_COSMOS_ENDPOINT")
        self.key = os.getenv("AZURE_COSMOS_KEY")
        self.database_name = "Vendors"
        self.container_name = "vendor_product_info"
        self.partition_key_path = "/vendor_code"  # Updated to match Azure
        self.partition_key_property = "vendor_code"  # Updated to match Azure
        self.id_property = "id"
        
        if not self.endpoint or not self.key:
            raise ValueError("AZURE_COSMOS_ENDPOINT and AZURE_COSMOS_KEY environment variables are required")
        
        # Initialize Cosmos client
        self.cosmos_client = AsyncCosmosClient(self.endpoint, self.key)
        
        # Initialize base class
        super().__init__(
            client=self.cosmos_client,
            db_name=self.database_name,
            container_name=self.container_name,
            automatic_id_generation=True  # Let Cosmos DB generate IDs automatically
        )
        
        self.is_initialized = False
        
    async def initialize(self):
        """Initialize the database and container"""
        if not self.is_initialized:
            await self.initialize_container(self.partition_key_path)
            self.is_initialized = True
            logging.info("VendorDataManager initialized successfully")
    
    def _convert_to_numeric(self, value) -> Optional[float]:
        """Convert string values to numeric, handling various formats and exceptions"""
        if value is None:
            return None
        
        try:
            # If already numeric, return as float
            if isinstance(value, (int, float)):
                return float(value)
            
            # Handle string conversion
            if isinstance(value, str):
                # Remove common non-numeric characters
                cleaned = value.strip().replace(',', '').replace('$', '').replace('₹', '').replace('€', '')
                
                # Handle empty strings after cleaning
                if not cleaned:
                    return None
                
                # Try to convert to float
                return float(cleaned)
            
            return None
        except (ValueError, TypeError) as e:
            logging.warning(f"Failed to convert '{value}' to numeric: {e}")
            return None
    
    def _convert_to_int(self, value) -> Optional[int]:
        """Convert string values to integer, handling exceptions"""
        numeric_value = self._convert_to_numeric(value)
        if numeric_value is not None:
            try:
                return int(numeric_value)
            except (ValueError, TypeError) as e:
                logging.warning(f"Failed to convert '{value}' to integer: {e}")
                return None
        return None

    def generate_vendor_code(self, vendor_name: str, vendor_country: str) -> str:
        """Generate a unique vendor_code for partition key"""
        # Create a deterministic vendor code based on name and country
        # Format: V + sequential number (simulating the V1000512 format from example)
        # For now, using hash-based approach
        country_prefix = vendor_country[:2].upper() if vendor_country else "XX"
        
        # Create hash of vendor name for uniqueness
        vendor_hash = hashlib.md5(f"{vendor_name}_{vendor_country}".encode('utf-8')).hexdigest()
        
        # Convert first 6 chars of hash to a number
        hash_num = int(vendor_hash[:6], 16) % 1000000
        
        return f"V{hash_num:07d}"
    
    def transform_supplier_to_document(self, supplier_data: Dict) -> Dict:
        """Transform supplier data to Cosmos DB document format"""
        # Generate vendor_code for partition key
        vendor_name = supplier_data.get("VendorName", "Unknown")
        vendor_country = supplier_data.get("VendorCountry", "Unknown")
        vendor_code = self.generate_vendor_code(vendor_name, vendor_country)
        
        # Create the document with required Cosmos DB fields (matching schema)
        # Note: 'id' field will be auto-generated by Cosmos DB
        document = {
            self.partition_key_property: vendor_code,  # Now uses "vendor_code"
            
            # Core vendor information (schema-compliant field names)
            "vendor_name": vendor_name,
            "vendor_country": vendor_country,
            "vendor_city": supplier_data.get("VendorCityorRegion"),
            "vendor_contact_information": supplier_data.get("VendorContactInformation"),
            "vendor_performance_rating": self._convert_to_numeric(supplier_data.get("VendorPerformanceRating")),
            
            # Product information (schema-compliant field names)
            "product_name": supplier_data.get("ProductName"),
            "unit_of_measure": supplier_data.get("UnitofMeasure"),
            "type": supplier_data.get("product_type"),
            "category": supplier_data.get("category"),
            
            # Pricing and order information (schema-compliant field names)
            "purchase_price": self._convert_to_numeric(supplier_data.get("PurchasePrice")),
            "currency": supplier_data.get("Currency"),
            "minimum_order_quantity": self._convert_to_int(supplier_data.get("MinimumOrderQuantity(MOQ)")),
            
            # Platform and metadata (schema-compliant field names)
            "source": supplier_data.get("Platform"),
            "notes": supplier_data.get("Notes"),
            
            # Additional fields to match schema
            "contact_source": supplier_data.get("ContactSource"),
            
            # Tracking fields
            "CreatedAt": datetime.utcnow().isoformat(),
            "LastUpdated": datetime.utcnow().isoformat(),
            "DataSource": "AI-Powered B2B Supplier Discovery",
            "ProcessingSession": datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        }
        
        # Remove None values to keep document clean
        return {k: v for k, v in document.items() if v is not None}
    
    async def store_supplier(self, supplier_data: Dict) -> str:
        """Store a single supplier in the database"""
        if not self.is_initialized:
            await self.initialize()
        
        document = self.transform_supplier_to_document(supplier_data)
        
        try:
            stored_doc = await self.create_item(document)
            vendor_code = document[self.partition_key_property]
            # Get the auto-generated ID from the stored document
            document_id = stored_doc.get(self.id_property, stored_doc.get('id'))
            
            logging.info(f"Stored supplier: {document['vendor_name']} with vendor_code: {vendor_code}, id: {document_id}")
            return document_id
            
        except Exception as e:
            logging.error(f"Failed to store supplier {document['vendor_name']}: {e}")
            raise
    
    async def store_suppliers_batch(self, suppliers_data: List[Dict]) -> List[str]:
        """Store multiple suppliers in the database"""
        if not self.is_initialized:
            await self.initialize()
        
        stored_ids = []
        
        logging.info(f"Storing {len(suppliers_data)} suppliers to Cosmos DB...")
        
        for i, supplier_data in enumerate(suppliers_data):
            try:
                document_id = await self.store_supplier(supplier_data)
                stored_ids.append(document_id)
                logging.info(f"✅ Stored supplier {i+1}/{len(suppliers_data)}: {supplier_data.get('VendorName', 'Unknown')}")
                
            except Exception as e:
                logging.error(f"❌ Failed to store supplier {i+1}/{len(suppliers_data)}: {e}")
                # Continue with other suppliers even if one fails
                continue
        
        logging.info(f"✅ Successfully stored {len(stored_ids)}/{len(suppliers_data)} suppliers")
        return stored_ids
    
    async def get_vendor_by_code(self, vendor_code: str) -> Optional[List[Dict]]:
        """Get all products for a vendor by vendor_code"""
        if not self.is_initialized:
            await self.initialize()
        
        query = "SELECT * FROM c WHERE c.vendor_code = @vendor_code"
        parameters = [{"name": "@vendor_code", "value": vendor_code}]
        
        try:
            results = await self.query_items(query, parameters, vendor_code)
            return results
        except Exception as e:
            logging.error(f"Failed to query vendor {vendor_code}: {e}")
            return None
    
    async def search_vendors_by_product(self, product_name: str) -> List[Dict]:
        """Search vendors by product name"""
        if not self.is_initialized:
            await self.initialize()
        
        # Use case-insensitive search
        query = "SELECT * FROM c WHERE CONTAINS(UPPER(c.product_name), UPPER(@product_name))"
        parameters = [{"name": "@product_name", "value": product_name}]
        
        try:
            results = await self.query_items(query, parameters)
            return results
        except Exception as e:
            logging.error(f"Failed to search products for '{product_name}': {e}")
            return []
    
    async def get_vendors_by_source(self, source: str) -> List[Dict]:
        """Get all vendors from a specific source"""
        if not self.is_initialized:
            await self.initialize()
        
        query = "SELECT * FROM c WHERE c.source = @source"
        parameters = [{"name": "@source", "value": source}]
        
        try:
            results = await self.query_items(query, parameters)
            return results
        except Exception as e:
            logging.error(f"Failed to query source {source}: {e}")
            return []
    
    async def close(self):
        """Close the Cosmos client"""
        if self.cosmos_client:
            await self.cosmos_client.close()
            logging.info("Cosmos DB client closed")

# Display data

if __name__ == "__main__":
    import asyncio
    import pandas as pd
    
    async def view_data_as_table():
        print("🔍 Viewing Cosmos DB data as table...")
        
        try:
            # Create the manager
            manager = VendorDataManager()
            print("✅ VendorDataManager created")
            
            # Initialize it
            await manager.initialize()
            print("✅ Connected to Cosmos DB successfully!")
            
            # Query ALL data
            print("📊 Fetching data...")
            
            query = "SELECT * FROM c"
            all_vendors = await manager.query_items(query)
            
            print(f"📈 Total records found: {len(all_vendors)}")
            
            if all_vendors:
                # Convert to DataFrame
                df = pd.DataFrame(all_vendors)
                
                # Display basic info
                print(f"\n📊 TABLE SHAPE: {df.shape[0]} rows × {df.shape[1]} columns")
                print(f"📋 COLUMNS: {list(df.columns)}")
                
                # Set pandas display options for better viewing
                pd.set_option('display.max_columns', None)  # Show all columns
                pd.set_option('display.width', None)        # Don't wrap
                pd.set_option('display.max_colwidth', 50)   # Limit column width
                
                print("\n" + "="*100)
                print("📋 FULL TABLE:")
                print("="*100)
                print(df)
                
                print("\n" + "="*50)
                print("📊 TABLE INFO:")
                print("="*50)
                print(df.info())
                
            else:
                print("📭 No records found in the database")
            
            # Close connection
            await manager.close()
            print("\n✅ Connection closed successfully!")
            
        except Exception as e:
            print(f"❌ Error: {e}")
    
    # Run the viewer
    asyncio.run(view_data_as_table())